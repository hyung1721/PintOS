			+---------------------------+
			|	   CS 330	    |
			| PROJECT 3: VIRTUAL MEMORY |
			|	DESIGN DOCUMENT	    |
			+---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

김우진 <hyung1721@kaist.ac.kr>
김준범 <dungeon12345@kaist.ac.kr>

---- PRELIMINARIES ----

# of tokens to use : 0

Contribution
김우진: 50%
김준범: 50%

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

다음은 threads/thread.h의 thread 구조제 선언에서 바뀐 부분이다.

    struct thread
    {
	...
        /* For project #3 */
        
        struct hash spt;                     
        int growth_cnt;
        
    };

spt는 supplemental page table로 각각의 process마다 있으며
page에 대한 추가적인 정보를 가지고 있다.
growth_cnt는 stack_growth를 할때 stack이 얼마나 자랐는지를 count하기 위해 사용하는 변수이다.

    struct spt_entry
    {
        struct hash_elem elem;        /* Hash element for hash table. */

        /* For project #3-1. */
        enum status state;            /* Status of frame. */
        void *upage;                  /* User virtual address. */
        void *paddr;                  /* Physical address. */

        bool writable;                /* Writable page or not. */
        struct thread *thread;        /* Thread which controls this entry.*/

        block_sector_t swap_index;    /* Location of frame in swap disk. */
	
	bool pinned;
        /* For lazy loading part of project #3-2. */
        struct file *file;
        size_t offset;
        size_t read_bytes;
        size_t zero_bytes;
    };

spt_entry는 supplemental page table에 들어갈 entry 구조체이다.
mapping된 frame의 state, frame의 address, swap_index 등의 변수를 가지고 있어
page fault가 일어났을 때 적절한 대응을 할 수 있도록 필요한 정보를 제공한다.

boolean 변수인 pinned는 spt_entry가 담고있는 특정 frame에 evict되지 않도록
표시하기 위한 변수이다. Pintos manual에 따라서, file 관련 함수를 호출하여 buffer를
사용해야 할때, buffer의 데이터가 담기는 frame을 pin, 즉, memory에 고정함으로써
이후 victim을 찾는 과정에서 swap disk로 내보내지지 않도록 하였다.

lazy loading을 구현하기 위해서 추가된 변수들은 executable file에 대한
정보를 저장한다.

다음은 vm/frame.h에 있는 extern 문이다.

    extern struct list frame_table;

frame_table은 현재 physical memory에서 사용 중인 frame들을 모은 list형태의 table이다.

    struct ft_entry
    {
        struct list_elem elem;

        void *frame;                /* The address of frame. */
        struct spt_entry *spte;     /* Connected spt_entry. */
        struct thread *t;           /* The thread which has a mapping to 
				       frame. */
    };

list로 구현된 frame_table에 들어갈 entry 구조체이다.
frame과 연결된 page의 spt_entry, frame을 사용 중인 thread pointer등을 가져
victim frame을 찾았을 때 mapping을 끊어주는 작업을 할 수 있다.

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

frame_alloc()에서 frame을 정상적으로 할당 받으면 install_page()를 통해 upage와의 
mapping을 만든다. User program이 특정 page를 참조하면 미리 이루어졌던 mapping을 통해 
frame을 locate한다. 만약 mapping이 존재하지 않으면 page fault가 일어나 frame에 대한 
정보를 가진 supplemental page table entry로 접근한다. supplemental page table 
entry의 status 인자를 통해 찾고자 한 frame이 어디에 있는지를 알게 되며, swap disk에 있는 
경우엔 swap in을 하여 frame을 가져온다.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

우리의 implementation은 page와 frame간의 mapping을 1-1 대응이 되도록 한다. 
즉, 하나의 page는 하나의 frame과만 mapping이 되어 특정 frame을 여러 page가 공유해서 쓰는 
경우가 없다. 따라서 aliasing이 일어나지 않아 관련한 case를 고려하지 않아도 됐다.
accessed bit는 victim frame을 찾을 때만 사용했으며 dirty bit는 따로 관리하지 않았다.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

frame을 실질적으로 얻는 작업은 pintos 자체에 내재된 palloc_get_page()를 통해 진행하는데, 
이 함수 내부에 lock이 있어 frame을 동시에 얻는 것에 대한 race를 방지한다.
또한, frame_alloc 함수안에 frame_table_lock이 swap out을 하는 작업에 대한 
synchronization을 맞춰서 race condition을 피할 수 있다.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

우리의 다음의 두 가지 이유로 인해 supplemental page table과 frame table을 만들었다.

1) VM을 구현해야 하기 때문에 user virtual address와 mapping되어 있는 frame은 
memory 상에 없을 수도 있다. 따라서 frame의 상태에 대한 추가적인 정보가 필요한데, 이를 프로세스
수준에서 다루기 위해서는 supplemental page table을 도입하여 각 user virtual address
와 frame의 mapping에 대한 정보를 관리해야 한다.

2) mapping된 frame을 swap disk와(다음 섹션에서 설명할 부분) memory 사이에서 관리해주기
위해서는 핀토스 커널 수준에서 전역 변수로써 frame table을 관리해줘야 한다. memory 내에
어느 부분이 사용 가능하고, 무엇을 내보내야 하는지는 모든 프로세스가 공유해야 하기 때문이다.

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

swap disk를 구현하기 위해서 vm/swap.c에 다음의 전역변수를 추가하였다.

	/* 1-1 mapping from swap_table to swap disk blocks. */
	struct bitmap *swap_table;
	struct lock swap_lock;
	struct block *swap_disk;

swap_table은 swap disk의 각 sector들이 사용 중인지 아닌지를 나타내는 bitmap이다.
swap_disk는 swap disk를 가리키는 block 포인터이며, pintos 부팅 과정에서 command
로 넣어준 swap.dsk가 swap disk로 설정된다.
swap_lock은 swapping out과 swapping in 작업이 critical section을 포함하고
있기 때문에 필요한 lock이다.

swap out된 frame 혹은, swap in될 frame을 physical memory 수준에서 관리하기
위해서 frame table을 만들었고, 다음의 전역 변수를 vm/frame.c에 추가하였다.

	struct list frame_table;
	struct lock frame_table_lock;

frame_table list에 담길 element를 위해서 다음의 구조체를 vm/frame.h에 추가하였다.

	struct ft_entry
	{
    	struct list_elem elem;

    	void *frame;                /* The address of frame. */
    	struct spt_entry *spte;     /* Connected spt_entry. */
    	struct thread *t;           /* The thread which has a mapping
				       to frame. */
	};

elem 변수는 frame_table list에서 list element로 접근하기 위해 필요하다.
frame은 이 element가 관리하는 frame의 physical memory address를 가리킨다.
spte는 이 frame에 대한 mapping이 있는 upage에 대한 supplemental page table
entry를 가리킨다.
t는 frame에 대한 mapping을 가지고 있는 thread를 가리킨다. frame table을 destroy
하는 과정에서 필요하다.


---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

우리는 LRU approximation으로써 second chance algorithm을 선택했다.
vm/frame.c:34의 frame_alloc() 함수에서는 memory가 꽉 차있는 상태라면 find_victim()
함수를 호출하여 swap disk로 내보낼 frame을 선정한다. find_victim()은 vm/swap.c:74
에 정의되어있으며, 다음의 과정을 통해서 frame을 선택한다.

1) frame_table에 가장 먼저 들어갔던 elem를 불러온다. (list의 맨 뒤 element)
2) list_entry 함수를 통해서 frame table entry로 접근한다.
3) pagedir_is_accessed() 함수를 통해서 access된 적이 있는 frame인지 확인한다.
4) access된 적이 있다면 accessed bit을 0으로 갱신해주고 다시 frame table 맨 앞으로
넣어준다. 그리고 1)~3의 과정을 반복한다.
5) access된 적이 있다면 frame과 대응되는 user virtual address 간의 mapping을 
끊어주고 이 entry를 리턴한다.

만약 모든 frame이 access된 적이 있다면, 처음 list에 포함되어 있던 frame이 evict frame
으로 선택된다.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

우리는 previously used frame가 다음의 두가지로 해석될 수 있다고 생각했다.

1) frame의 data가 이전에 사용된 적이 있다.
2) frame이 저장되어 있는 메모리 주소가 이전에 사용된 적이 있다.

1)의 경우는 우리의 implementation에서는 일어나지 않는 일이다. 하나의 user virtual address
는 하나의 frame에 연결되어 있고, 더 이상 frame을 쓰지 않으면 palloc_free_page()을
호출하여 frame의 data를 지우기 때문이다.
2)의 경우는 프로세스가 종료되거나 frame이 evict되는 과정에서 pagedir_clear_page()
함수를 통해서 user virtual address - frame 의 mapping을 끊어주기 때문에
프로세스 Q가 더 이상 이 frame을 사용하지 않는다는 것을 보장할 수 있다.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

Stack growth로 인해서 발생하는 page_fault을 handle하기 위해서 우리는 다음의 코드를 
userprog/exception.c:178에 추가하였다.
	
	...
	else if (fault_addr >= f->esp - STACK_HEURISTIC)
      	{
        	load = stack_growth(fault_addr);
      	}
	...

여기서 STACK_HEURISTIC은 32라는 값을 가지는 매크로 변수이다.

위 if문에서는 fault가 발생한 user address가 현재 스택을 벗어나는 access인지를 확인한다.
현재 스택 포인터에서 PUSHA instruction을 통해서 일어날 수 있는 최대 변동값은 32이다. 
fault address가 이 변동범위 내에서 발생하면 stack을 위한 새로운 page를 할당해줘야
하므로 stack_growth() 함수를 호출한다.

stack_growth() 함수는 userprog/process.c:694에 정의되어 있으며, 최대 8MB까지
stack의 크기가 커질 수 있도록 page를 새로 할당한다.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

우리의 VM synchronization은 크게 vm/swap.c의 swap_lock과 vm/frame.c의 
frame_table_lock을 통해서 이루어진다.

swap_lock은 swap_in(), swap_out()의 작업을 동시에 두 프로세스가 진행하지 못하도록
하기 위해서 필요하다. frame_table_lock은 frame table에 접근하는 작업을 동시에 두
프로세스가 진행하지 못하도록 하기 위해서 필요하다.

두 lock은 서로 nested된 상태로 acquire & release되지 않고, separate된 부분에서
사용되기 때문에 deadlock이 일어날 수 없다.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

우선 process P가 eviction process에 도달하면 우리의 implementation에서는 
find_victim() 함수를 호출한다. 이 함수에서는 victim을 찾음과 동시에 해당 victim frame
에 대한 mapping을 가지고 있는 process Q의 mapping을 끊어준다. 그리고, swap_out()
을 호출하여 victim frame을 swap disk로 내보낸 후 frame_table_lock을 release한다.
만약 victim frame이 swap out되기 이전에 process Q가 access하려고 시도한다면
이미 find_victim()에서 process P가 mapping을 끊어주었기 때문에 process Q는 page
fault를 만나게 되고 swap disk로부터 load하기 위해서 결국은 다시 frame_alloc() 함수
에 들어와 frame_table_lock이 release되기를 기다린다. 따라서 process Q는 P가 
eviction process를 끝내기 전에는 victim frame에 access하거나 modify할 수 없다. 

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

swap_in()와 swap_out()는 모두 swap_lock에 의해서 synch가 된다.
swap disk로부터 page를 읽는 과정은 swap_in()에 포함되기 때문에 특정 process가 
swap_in()을 하는 동안 다른 process는 swap_out()을 할 수 없다 따라서 특정 frame이 
읽어지는 동안 다른 process에 의해 evict되는 등의 방해는 불가능하다.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

User program이 paged_out page에 access를 하면 page와 mapping된 frame이 없기 때문에 
page_fault가 일어난다. Page_fault hanlder는 supplemental page table에서 해당 page와 
관련한 entry를 찾고 frame이 저장된 disk의 index를 받아 동일한 data를 가진 새로운 frame을 
만들어 user program이 access할 수 있게 한다. 이때 invalid한 address는 page fault 
handling 전에 미리 검사하여 syscall_exit()을 부른다.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

우리의 implementation에서는 swap_lock과 frame_table_lock 총 2개를 사용했다.
swap_in,out 같은 operation과 frame_table은 여러 process에 의해 공유되기 떄문에
한번에 하나의 process만 할 수 있도록 synch를 맞출 필요가 있어 각각에 대한 lock을 만들었다.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
{
    struct file *mmap_table[FD_MAX_SIZE]; /* Array of memory mapped file pointer. */
}

각 thread마다 가진 mmap_table로 file*를 element로 가진 array이다.
file descripter가 fd인 File을 mmap하면 mmap_table의 index가 fd인 곳에 해당 
파일의 file*가 저장된다.

enum status {
    SWAP_DISK,                    /* Frame is in swap disk. */
    MEMORY,                       /* Frame is in physical memory. */
    EXEC_FILE,                     /* Frame is executable file. */
    MMAP             
};

spt_entry의 status에 MMAP state를 추가했다.
mmap도 lazy loading이 되어야 함으로 처음 spte를 만들 때 MMAP state를 갖게하여
page fault때 적절한 handling을 할 수 있다.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

사용자가 호출하는 mmap()은 syscall_handler를 통해 syscall_mmap()을 부른다.
이때 kernel은 mmap할 파일을 page size만큼 잘라, 반복문을 돌며 spt_entry를 만든다.
이때 사용되는 함수가 create_spte_from_mmap()이고 이 함수에서 spt_entry의 state가 
MMAP으로 정해진다.

이후, 사용자가 mapping된 frame을 사용하고자 하면 page fault가 발생하여 page fault
handler가 실행된다. handler에서 spt_entry의 state가 MMAP인 경우 load_from_mmap()을 
통해 physical memory에 file의 내용이 load가 되어 사용자는 frame를 참조하는 것으로 
파일을 읽는 것과 같은 효과를 얻게 된다.

mmap()을 통해 load한 frame은 일반적인 frame과 eviction process가 다르다.
일반적인 frame은 evict를 하게 될 경우, swap_disk로 옮기면 끝이지만, mmap()으로 
load된 frame은 evict시 file에 변경된 내용을 옮겨주고 swap_disk로 옮겨야 한다.

우리는 이것을 구현하기 위해서 supplemental page table entry에 mmaped boolean
변수를 추가하였다. mmap()의 호출로 인해서 만들어진 spte라면 mmaped의 값이 true로 설정되고,
이후 victim을 고르는 과정에서 spte의 mmaped값을 검사한다. 만약 true라면 spte에 담긴
file의 정보를 통해서 frame의 내용을 file에 write하고 swap disk로 옮긴다.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

새로운 file mapping이 생기는 경우는 프로세스가 mmap() system call을 호출하였을 때다.
우리는 이때 mmap()의 인자로 받은 address부터 시작하여 file의 크기를 더한 만큼의 address까지
순회하며 이미 만들어진 supplemental page table entry가 있는지 검사한다.
만약 있다면, stack, data, code 등의 segment를 침범하게 되는 것이므로 exit(-1)을
호출하여 프로세스가 종료되도록 한다. 

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

executables를 load하기 위해서 만든 함수는 load_from_exec()이고, mmap file을
load하기 위해서 만든 함수는 load_from_mmap()이다.

처음에는 두 함수의 목적이 다르기 때문에 분리하여 구현을 하였으나, 결국은 두 함수 모두 file의 
내용을 physical memory로 불러오는 것이기 때문에 내부 구현의 차이점은 없었다.

하지만, 코드의 이해를 돕고자 우리는 분리된 형태로 함수를 사용하였다.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?